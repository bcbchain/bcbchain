package gen

import (
	"github.com/bcbchain/bcbchain/smccheck/parsecode"
	"bytes"
	"path/filepath"
	"strings"
	"text/template"
)

var receiptTemplate = `package {{.PackageName}}

{{if .Imports}}import ({{end}}
  {{range $v,$vv := .Imports}}
{{$v.Name}} {{$v.Path}}{{end}}
{{if .Imports}}){{end}}

// This file is auto generated by BCB-goland-plugin.
// Don't modified it

{{range $i, $m := .Methods}}
func ({{$.ReceiverName}} *{{$.ContractName}}) {{$m.Name}}({{range $ip,$para := $m.Params}}{{$para|expandNames}} {{$para|expandType}},{{end}}) {
	type {{$m.Name | m2s}} struct {        {{range $if,$sf := $m.SingleParams}}
             {{$sf|expandNames|upperFirst}} {{$sf|expandType}}  ` + "`" + `json:"{{$sf|expandNames}}"` + "`" + `{{end}}
	}

	{{$.ReceiverName}}.sdk.Helper().ReceiptHelper().Emit({{$m.Name | m2s}}{    {{range $if,$sf := $m.SingleParams}}
             {{$sf|expandNames|upperFirst}}: {{$sf|expandNames}}, {{end}}
	})
}
{{end}}
`

// FatMethod - the method describe, easy to export
type FatMethod struct {
	parsecode.Method
	SingleParams []parsecode.Field // expand the names of param field to multiple field with same type
}
type receiptExport struct {
	baseExport
	Imports map[parsecode.Import]struct{}
	Methods []FatMethod
}

func res2Receipt(res *parsecode.Result) receiptExport {
	rec := receiptExport{}

	rec.PackageName = res.PackageName
	rec.ReceiverName = strings.ToLower(string([]rune(res.ContractStructure)[0]))
	rec.ContractName = res.ContractStructure
	imports := make(map[parsecode.Import]struct{})

	fatMethods := make([]FatMethod, 0, len(res.Receipts))
	for _, method := range res.Receipts {
		fat := FatMethod{
			Method: method,
		}
		singleParams := make([]parsecode.Field, 0)
		for _, para := range method.Params {
			for imp := range para.RelatedImport {
				imports[imp] = struct{}{}
			}
			singleParams = append(singleParams, parsecode.FieldsExpand(para)...)
		}
		fat.SingleParams = singleParams
		fatMethods = append(fatMethods, fat)
	}
	rec.Methods = fatMethods
	rec.Imports = imports

	return rec
}

// focus to generate logic
// nolint unhandled - because WriteString always return (error)nil
func GenReceipt(inPath string, res *parsecode.Result) {
	filename := filepath.Join(inPath, res.PackageName+"_autogen_receipt.go")

	funcMap := template.FuncMap{
		"upperFirst":  parsecode.UpperFirst,
		"lowerFirst":  parsecode.LowerFirst,
		"expandNames": parsecode.ExpandNames,
		"expandType":  parsecode.ExpandType,
		"m2s":         m2s,
	}
	tmpl, err := template.New("receipt").Funcs(funcMap).Parse(receiptTemplate)
	if err != nil {
		panic(err)
	}

	rec := res2Receipt(res)

	var buf bytes.Buffer

	if err = tmpl.Execute(&buf, rec); err != nil {
		panic(err)
	}

	if err := parsecode.FmtAndWrite(filename, buf.String()); err != nil {
		panic(err)
	}
}

// method name to struct name
func m2s(m string) string {
	return parsecode.LowerFirst(m[4:])
}
